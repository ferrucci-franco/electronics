<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Incremental Encoder ‚Äì Interactive</title>
<style>
  :root{
    --bg:#0f1222; --fg:#e9ecf4; --muted:#a9b0c3; --card:#1a2036;
    --accent:#5aa9ff; --grid:#273054; --axis:#3a476f;
    --a:#8fd3ff; --b:#ffb686; --red:#ff4d4d;
    --material:#1a9c65;
  }
  [data-theme="light"]{
    --bg:#ffffff; --fg:#111624; --muted:#55607a; --card:#f5f7fb;
    --accent:#0b6cff; --grid:#d6dbee; --axis:#c3cbe4;
    --a:#0b6cff; --b:#ff8b3d; --red:#d62828;
    --material:#1a9c65;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{max-width:1100px;margin:0 auto;padding:16px}

  .topbar{display:flex;align-items:center;gap:12px}
  .title{font-size:20px;font-weight:700;flex:1}
  .seg{display:inline-flex;background:var(--card);border:1px solid var(--grid);border-radius:14px;overflow:hidden}
  .seg button{border:0;background:transparent;color:var(--muted);padding:8px 14px;font-weight:600;cursor:pointer}
  .seg button.active{background:var(--bg);color:var(--fg)}
  /* ‚Äî‚Äî‚Äî Mejora de contraste en tema claro (segmento activo) ‚Äî‚Äî‚Äî */
  [data-theme="light"] .seg button.active{
    background:#eaf2ff; /* fallback */
    background:color-mix(in srgb, var(--accent) 14%, #fff);
    color:var(--fg);
    box-shadow: inset 0 0 0 2px var(--accent);
  }
  [data-theme="light"] .seg button:not(.active){
    opacity:.75;
  }
  /* Accesibilidad: anillo de foco visible */
  .seg button:focus-visible{
    outline:2px solid var(--accent);
    outline-offset:2px;
  }
  
  .iconbtn{border:1px solid var(--grid);background:var(--card);border-radius:14px;padding:8px 10px;cursor:pointer;font-weight:700}
  /* Bot√≥n media (play/pause) con SVG */
  .iconbtn--media{display:inline-flex;align-items:center;justify-content:center;gap:6px;min-width:40px}
  .iconbtn--media svg{width:16px;height:16px;display:block;fill:currentColor}
  /* M√°s contraste en tema claro */
  [data-theme="light"] .iconbtn--media{background:#fff}
  /* ‚Äî‚Äî‚Äî Colores para estado "running" ‚Äî‚Äî‚Äî */
  :root{
    --play-on-bg:#1f8f4d; /* dark theme */
    --play-on-fg:#ffffff;
  }
  [data-theme="light"]{
    --play-on-bg:#27ae60; /* light theme */
    --play-on-fg:#ffffff;
  }
  .iconbtn--media.is-running{
    background:var(--play-on-bg)!important;
    color:var(--play-on-fg)!important;
    border-color:transparent!important;
    box-shadow:inset 0 0 0 2px color-mix(in srgb, var(--play-on-bg) 35%, transparent);
  }  
  
  .grid{display:grid;grid-template-columns:420px 1fr;gap:16px;margin-top:12px}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} }
  .card{background:var(--card);border-radius:14px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,.12)}
  .subtitle{font-weight:700;margin-bottom:8px}

  .wheelbox{display:grid;place-items:center;height:420px}
  .hint{color:var(--muted);font-size:13px}

  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  select,input[type="range"],button{background:#0f1528;border:1px solid var(--grid);color:var(--fg);border-radius:10px;padding:8px 10px}
  [data-theme="light"] select,[data-theme="light"] input[type="range"],[data-theme="light"] button:not(.primary){background:#fff}
  .primary{background:var(--accent)!important;border-color:transparent;color:#fff!important;font-weight:700}
  input[type="range"]{width:260px}
  .rpmval{min-width:56px;display:inline-block;text-align:right}
  .disabled{opacity:.45;filter:saturate(.2)}
  button{cursor:pointer}

  .metrics{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
  @media (max-width:880px){ .metrics{grid-template-columns:repeat(2,minmax(0,1fr))} }
  .metric{min-width:0;background:transparent;border:1px solid var(--grid);border-radius:12px;padding:10px}
  .metric .h{color:var(--muted);font-size:12px;margin-bottom:8px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .metric .v{font-size:18px;font-weight:700}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace}

  .legend{display:flex;gap:12px;font-size:13px;color:var(--muted)}
  .dot{width:10px;height:10px;border-radius:50%;display:inline-block;vertical-align:middle;margin-right:6px}
  .dot.a{background:var(--a)} .dot.b{background:var(--b)}

  .plots{display:grid;grid-template-columns:1fr;gap:10px;margin-top:10px}
  canvas{display:block;width:100%;height:140px;background:transparent;border:1px solid var(--grid);border-radius:12px}
  .hintcard{margin-top:10px;border:1px solid var(--grid);border-radius:12px;padding:12px;background:transparent}
  .hintcard .hint{font-size:18px}
  
  /* Colores RPM (se sobre-escriben desde JS si quieres) */
  :root{
    --rpm-neg: #ff6b6b;  /* barra/texto para rpm < 0 */
    --rpm-pos: #2ecc71;  /* barra/texto para rpm > 0 */
  }
  
  /* Pista bicolor con corte al centro */
  #rpm::-webkit-slider-runnable-track{
    height:10px; border-radius:999px;
    background:linear-gradient(90deg,var(--rpm-neg) 0 50%, #0000 50% 50%, var(--rpm-pos) 50% 100%);
    outline:1px solid var(--grid);
  }
  #rpm::-moz-range-track{
    height:10px; border-radius:999px;
    background:linear-gradient(90deg,var(--rpm-neg) 0 50%, #0000 50% 50%, var(--rpm-pos) 50% 100%);
    outline:1px solid var(--grid);
  }
  
  /* Thumb */
  #rpm::-webkit-slider-thumb{
    appearance:none; width:18px; height:18px; border-radius:50%;
    background:#fff; border:2px solid #0003; margin-top:-4px;
    box-shadow:0 2px 6px rgba(0,0,0,.25);
  }
  #rpm::-moz-range-thumb{
    width:18px; height:18px; border-radius:50%;
    background:#fff; border:2px solid #0003; box-shadow:0 2px 6px rgba(0,0,0,.25);
  }
</style>
</head>
<body data-theme="dark">
<div class="wrap">
  <div class="topbar">
    <div class="title" id="t_title">Incremental Encoder ‚Äì Interactive</div>
    <div class="seg" id="langSeg">
      <button data-lang="en" class="active">EN</button>
      <button data-lang="fr">FR</button>
      <button data-lang="es">ES</button>
    </div>
    <button id="themeBtn" class="iconbtn" title="Theme">üåì</button>
  </div>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <div class="subtitle" id="t_wheel">Wheel (drag to rotate)</div>
      <div class="wheelbox">
        <svg id="wheel" width="360" height="360" viewBox="0 0 360 360" aria-label="Encoder wheel">
          <defs>
            <mask id="maskA"></mask>
            <mask id="maskB"></mask>
          </defs>

          <!-- Sensors BELOW rotor so opaque material hides them -->
          <g id="sensors">
            <circle id="dotA" r="6" fill="var(--a)"/>
            <text id="labA" font-size="12" fill="var(--a)" style="display:none">A</text>
            <circle id="dotB" r="6" fill="var(--b)"/>
            <text id="labB" font-size="12" fill="var(--b)" style="display:none">B</text>
          </g>

          <!-- Rotor -->
          <g id="rotor">
            <circle cx="180" cy="180" r="150" fill="var(--material)" mask="url(#maskA)"></circle>
            <circle cx="180" cy="180" r="110" fill="transparent"></circle>
            <circle cx="180" cy="180" r="100" fill="transparent"></circle>
            <circle cx="180" cy="180" r="100" fill="var(--material)" mask="url(#maskB)"></circle>
            <circle cx="180" cy="180" r="70" fill="transparent"></circle>
          </g>
          <circle cx="180" cy="180" r="8" fill="transparent"></circle>
        </svg>
      </div>
      <div class="hintcard"><div class="hint" id="t_hintDrag">Tip: drag with mouse/touch. Shift snaps to 5¬∞. Use ‚Üê/‚Üí too.</div></div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="subtitle" id="t_mode">Mode</div>
      <div class="row" style="margin-bottom:8px">
        <div class="seg" id="modeSeg">
          <button data-mode="manual" class="active" id="btnManual">Manual</button>
          <button data-mode="const" id="btnConst">Constant speed</button>
        </div>
        <button id="play" class="iconbtn iconbtn--media" title="Play" aria-pressed="false" disabled>
          <!-- Play -->
          <svg class="icon-play" viewBox="0 0 24 24" aria-hidden="true">
            <polygon points="8,5 19,12 8,19"></polygon>
          </svg>
          <!-- Pause -->
          <svg class="icon-pause" viewBox="0 0 24 24" aria-hidden="true" hidden>
            <rect x="6" y="5" width="4" height="14" rx="1.5"></rect>
            <rect x="14" y="5" width="4" height="14" rx="1.5"></rect>
          </svg>
        </button>
        <button id="reset" class="primary"><span id="t_reset">Reset</span></button>
      </div>

      <div class="row" id="rpmRow">
        <label for="rpm"><span id="t_rpm">RPM</span></label>
        <input id="rpm" type="range" min="-10" max="10" step="0.1" value="0">
        <span class="rpmval mono" id="rpmVal">0.0</span>
      </div>

      <div class="row" style="margin-top:6px">
        <label id="t_countMode">Counting</label>
        <select id="countMode">
          <option value="x4">All edges (√ó4)</option>
          <option value="x2">A edges (rise &amp; fall) (√ó2)</option>
          <option value="x1">A rising edges (√ó1)</option>
        </select>
        <label for="ppr" id="t_ppr" style="margin-left:8px">PPR</label>
        <input id="ppr" type="number" min="1" max="1024" step="1" value="10" style="width:90px" />
        <span id="resInfo" class="mono" style="opacity:.8"></span>
      </div>

      <div class="metrics" style="margin-top:10px">
        <div class="metric">
          <div class="h" id="t_absCount">Counter (abs)</div>
          <div class="v mono" id="m_abs">0</div>
        </div>
        <div class="metric">
          <div class="h" id="t_trueAngle">True angle (deg)</div>
          <div class="v mono" id="m_true">0.00¬∞</div>
        </div>
        <div class="metric">
          <div class="h" id="t_angleAbs">Measured angle</div>
          <div class="v mono" id="m_angAbs">0.00¬∞</div>
        </div>
      </div>

      <div class="legend" style="margin-top:8px">
        <span><i class="dot a"></i>A</span>
        <span><i class="dot b"></i>B</span>
      </div>
      <div class="plots">
        <canvas id="plotA" width="800" height="140" aria-label="Signal A"></canvas>
        <canvas id="plotB" width="800" height="140" aria-label="Signal B"></canvas>
      </div>
    </div>
  </div>
</div>

<script src="encoder_svg.js"></script>
<script>
/* ==== Theme ==== */
const themeBtn=document.getElementById('themeBtn');
const savedTheme=localStorage.getItem('enc_theme');
if(savedTheme) document.body.setAttribute('data-theme', savedTheme);
themeBtn.textContent=document.body.getAttribute('data-theme')==='light'?'üåû':'üåì';
themeBtn.onclick=()=>{ const cur=document.body.getAttribute('data-theme');
  const next=(cur==='light')?'dark':'light'; document.body.setAttribute('data-theme',next);
  localStorage.setItem('enc_theme',next); themeBtn.textContent=next==='light'?'üåû':'üåì'; };

/* ==== I18N ==== */
const I18N={
  en:{title:"Incremental Encoder ‚Äì Interactive",wheel:"Wheel (drag to rotate)",
    hint:"Tip: drag with mouse/touch. Shift snaps to 5¬∞. Use ‚Üê/‚Üí too.",
    mode:"Mode",manual:"Manual",const:"Constant speed",rpm:"RPM",count:"Counting",
    reset:"Reset",abs:"Counter (abs)",tangle:"True angle (deg)",mangle:"Measured angle",
    ppr:"PPR",
    x4:"All edges (√ó4)",x2:"A edges (rise & fall) (√ó2)", x1:"Rising edge of A (√ó1)"},
  es:{title:"Encoder incremental ‚Äì Interactivo",wheel:"Rueda (arrastra para girar)",
    hint:"Tip: arrastra con mouse/touch. Shift: 5¬∞. Tambi√©n ‚Üê/‚Üí.",
    mode:"Modo",manual:"Manual",const:"Velocidad constante",rpm:"RPM",count:"Conteo",
    reset:"Reset",abs:"Contador (absoluto)",tangle:"√Ångulo real (deg)",mangle:"√Ångulo medido",
    ppr:"PPR",
    x4:"Todos los flancos (√ó4)",x2:"Flancos de A (¬±) (√ó2)", x1:"Flancos de subida de A (√ó1)"},
  fr:{title:"Codeur incr√©mental ‚Äì Interactif",wheel:"Roue (faire glisser pour tourner)",
    hint:"Astuce : Maj = 5¬∞. Aussi ‚Üê/‚Üí.",
    mode:"Mode",manual:"Manuel",const:"Vitesse constante",rpm:"RPM",count:"Comptage",
    reset:"Reset",abs:"Compteur (absolu)",tangle:"Angle r√©el (deg)",mangle:"Angle mesur√©",
    ppr:"PPR",
    x4:"Tous les fronts (√ó4)",x2:"Fronts de A (montants & descendants) (√ó2)", x1:"Fronts montants de A (√ó1)"}
};
function setLang(code){
  const t=I18N[code]||I18N.en;
  document.getElementById('t_title').textContent=t.title;
  document.getElementById('t_wheel').textContent=t.wheel;
  document.getElementById('t_hintDrag').textContent=t.hint;
  document.getElementById('t_mode').textContent=t.mode;
  document.getElementById('btnManual').textContent=t.manual;
  document.getElementById('btnConst').textContent=t.const;
  document.getElementById('t_rpm').textContent=t.rpm;
  document.getElementById('t_countMode').textContent=t.count;
  document.getElementById('t_ppr').textContent=t.ppr;
  document.getElementById('t_reset').textContent=t.reset;
  document.getElementById('t_absCount').textContent=t.abs;
  document.getElementById('t_trueAngle').textContent=t.tangle;
  document.getElementById('t_angleAbs').textContent=t.mangle;
  const sel=document.getElementById('countMode');
  sel.options[0].text=t.x4; 
  sel.options[1].text=t.x2;
  sel.options[2].text = t.x1; 
  const tip = document.getElementById('t_hintDrag');
  tip.textContent = t.hint;
  tip.style.fontWeight = '700';
  tip.style.setProperty('font-size', '18px', 'important');
}
const langSegEl=document.getElementById('langSeg');
langSegEl.addEventListener('click',e=>{
  if(e.target.tagName!=='BUTTON') return;
  [...langSegEl.children].forEach(b=>b.classList.remove('active'));
  e.target.classList.add('active');
  setLang(e.target.dataset.lang);
});
setLang('en');

/* ==== Config ==== */
const RPM_POS_COLOR = '#5fbfad';
const RPM_NEG_COLOR = '#e07b7b';
let PPR=10;
const VIEW_FACTOR = 0.8;
function oddParityDeg(){ return (PPR % 2) ? (180/PPR) : 0; }
const SNAP_DEG=5;
const KEY_STEP_DEG=1;
const PHASE_A_ELEC=-0.25;
const PHASE_B_ELEC=-0.5;
const SENSOR_AZIMUTH_DEG = -90;
const TRUE_ANGLE_DIR = 1;
const COUNT_DIR = 1;
const INIT_OFFSET_DEG = 0;

/* ==== Geometr√≠a y rotor ==== */
const CX=180, CY=180;
const R_EXT=150, R_CORE=20;
const R_A_IN=40, R_A_OUT=80;
const R_B_IN=90, R_B_OUT=130;
const NOTCH_angle=0, NOTCH_deg=15, NOTCH_depth=8;
const viewMarginRATIO = 0.08;

// aplica a CSS vars para la pista
document.documentElement.style.setProperty('--rpm-pos', RPM_POS_COLOR);
document.documentElement.style.setProperty('--rpm-neg', RPM_NEG_COLOR);

// Construcci√≥n del rotor (usa buildEncoderSVG de encoder_svg.js)
(function(){
  try{
    var materialColor = getComputedStyle(document.body).getPropertyValue('--material').trim() || '#1fbf7a';
    var diskSVG = buildEncoderSVG({
      n: PPR,
      duty: 0.5,
      Rext: R_EXT,
      Rcore: R_CORE,
      A_in: R_A_IN,  A_out: R_A_OUT,
      B_in: R_B_IN, B_out: R_B_OUT,
      notchAngleDeg: NOTCH_angle,
      notchWidthDeg: NOTCH_deg,
      notchDepth: NOTCH_depth,
      viewMarginRatio: viewMarginRATIO,
      width: 360, 
      height: 360,
      fillColor: materialColor,
      showOutlines: false
    });
    document.getElementById('rotor').innerHTML = diskSVG;
  }catch(e){ console.error(e); }
})();
// sensores en el centro radial de cada pista (arriba)
const dotA=document.getElementById('dotA'), dotB=document.getElementById('dotB');
const labA=document.getElementById('labA'), labB=document.getElementById('labB');
(function placeDots(){
  const rB=(R_A_IN+R_A_OUT)/2;
  const rA=(R_B_IN+R_B_OUT)/2;
  dotA.setAttribute('cx',CX); 
  dotA.setAttribute('cy',CY-rA*(1+viewMarginRATIO));
  labA.setAttribute('x',CX+12); 
  labA.setAttribute('y',CY-rA+4);
  dotB.setAttribute('cx',CX); 
  dotB.setAttribute('cy',CY-rB*(1+viewMarginRATIO));
  labB.setAttribute('x',CX+12); 
  labB.setAttribute('y',CY-rB+4);
})();

/* ==== Estado & controles ==== */
let thetaDeg=0, lastThetaDeg=0;         // √°ngulo real acumulativo (CCW positivo)
let mode='manual', running=false;
let rpm=0;
let countModeVal='x4';
let countAbsX4=0, countAbsX2=0, countAbsX1 = 0;
let tSim=0, lastSampleT=-1, winWindow=0.5;
let keyMovePending=false;

const modeSeg=document.getElementById('modeSeg');
const playBtn=document.getElementById('play');
const resetBtn=document.getElementById('reset');
const rpmRow=document.getElementById('rpmRow');
const rpmSlider=document.getElementById('rpm');
const rpmVal=document.getElementById('rpmVal');
const countModeEl=document.getElementById('countMode');
rpmSlider.oninput = ()=>{
  rpm = +rpmSlider.value;
  rpmVal.textContent = rpm.toFixed(1);
  rpmVal.style.color = (rpm > 0) ? RPM_POS_COLOR
                     : (rpm < 0) ? RPM_NEG_COLOR
                     : getComputedStyle(document.body).getPropertyValue('--fg').trim();
};

// Estado inicial: Manual -> slider deshabilitado
(function initManual(){
  rpmSlider.disabled=true; rpmRow.classList.add('disabled'); playBtn.disabled=true;
  rpmVal.textContent=(+rpmSlider.value).toFixed(1);
})();

modeSeg.addEventListener('click',e=>{
  if(e.target.tagName!=='BUTTON') return;
  [...modeSeg.children].forEach(b=>b.classList.remove('active'));
  e.target.classList.add('active');
  mode=e.target.dataset.mode;
  const isConst=(mode==='const');
  rpmRow.classList.toggle('disabled',!isConst);
  rpmSlider.disabled=!isConst;
  playBtn.disabled=!isConst;
  if(!isConst){ running=false; setPlayVisual(false); }
});

function setPlayVisual(isRunning){
  playBtn.setAttribute('aria-pressed', String(isRunning));
  playBtn.title = isRunning ? 'Pause' : 'Play';
  const p = playBtn.querySelector('.icon-play');
  const q = playBtn.querySelector('.icon-pause');
  if(p && q){ p.hidden = isRunning; q.hidden = !isRunning; }
  playBtn.classList.toggle('is-running', !!isRunning);  
}
playBtn.onclick=()=>{ running=!running; setPlayVisual(running); };
setPlayVisual(false);

// Cambiar tipo de conteo: NO resetear nada; solo cambiar lo que se muestra
countModeEl.onchange=e=>{
  countModeVal=e.target.value;
  updateMetrics();
  updateResInfo();
  onCountingParamsChanged();
};

// === PPR control ===
const pprInput = document.getElementById('ppr');
if(pprInput) pprInput.value = PPR;

function rebuildRotor(){
  try{
    var materialColor = getComputedStyle(document.body).getPropertyValue('--material').trim() || '#1fbf7a';
    var diskSVG = buildEncoderSVG({
      n: PPR, duty: 0.5,
      Rext: R_EXT, Rcore: R_CORE,
      A_in: R_A_IN, A_out: R_A_OUT,
      B_in: R_B_IN, B_out: R_B_OUT,
      notchAngleDeg: NOTCH_angle, notchWidthDeg: NOTCH_deg, notchDepth: NOTCH_depth,
      viewMarginRatio: viewMarginRATIO, width: 360, height: 360,
      fillColor: materialColor, showOutlines: false
    });
    document.getElementById('rotor').innerHTML = diskSVG;
  }catch(e){ console.error('rebuildRotor error', e); }
}

function resetAll(){
  thetaDeg=0; lastThetaDeg=0;
  thetaCumDeg=0; q4_prev=0; phaseOffCycles=0;
  countAbsX4=0; countAbsX2=0; countAbsX1=0;
  tSim=0; lastSampleT=-1; winWindow=0.5;
  tSeriesA.length=0; tSeriesB.length=0;
  drawPlots(true);
  updateMetrics();
  const phi=(((thetaDeg + INIT_OFFSET_DEG + oddParityDeg())%360)+360)%360;
  rotorEl.setAttribute('transform',`rotate(${phi} ${CX} ${CY})`);
  onCountingParamsChanged();
}

function updateResInfo(){
  const cpr = currentCPR();
  const el = document.getElementById('resInfo');
  if(!el) return;
  const resDeg = 360/Math.max(1, cpr);
  el.textContent = `Resolution: ${resDeg.toFixed(4)}¬∞/count  (${cpr} counts/rev)`;
}

if(pprInput){
  const commit = ()=>{
    let v = Math.floor(+pprInput.value||PPR);
    if (v < 1) v = 1;
    if (v > 1024) v = 1024;
    PPR = v;
    rebuildRotor();
    resetAll();
    updateResInfo();
    onCountingParamsChanged();
  };
  pprInput.addEventListener('change', commit);
  pprInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') { e.preventDefault(); commit(); }});
}

setTimeout(updateResInfo, 0);
resetBtn.onclick=()=>{ resetAll(); };

/* ==== Arrastre (CCW positivo) ==== */
const wheelSVG=document.getElementById('wheel');
let dragging=false, prevAng=null;
function angleAt(evt){
  const r=wheelSVG.getBoundingClientRect();
  return Math.atan2((evt.touches?evt.touches[0].clientY:evt.clientY)-r.top-r.height/2,
                    (evt.touches?evt.touches[0].clientX:evt.clientX)-r.left-r.width/2)*180/Math.PI;
}
wheelSVG.addEventListener('pointerdown',e=>{ wheelSVG.setPointerCapture(e.pointerId); dragging=true; prevAng=angleAt(e); });
window.addEventListener('pointermove',e=>{
  if(!dragging || mode!=='manual') return;
  const a=angleAt(e);
  let d=a-prevAng; d=((d+540)%360)-180;
  thetaDeg += d;
  prevAng=a;
  if(e.shiftKey){ thetaDeg=Math.round(thetaDeg/SNAP_DEG)*SNAP_DEG; }
});
window.addEventListener('pointerup',()=>{ dragging=false; prevAng=null; });

/* ==== Teclado ‚Üê/‚Üí ==== */
window.addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft' || e.key==='ArrowRight'){
    e.preventDefault();
    const mul=e.shiftKey?5:1;
    const step = mul*KEY_STEP_DEG*(e.key==='ArrowRight'? +1 : -1);
    thetaDeg += step; keyMovePending=true;
  }
});

/* ==== Se√±ales y conteo en paralelo (CCW = +1) ==== */
function ABfromTheta(th){
  th += INIT_OFFSET_DEG + oddParityDeg();
  th += SENSOR_AZIMUTH_DEG;
  let eA=th/360*PPR + PHASE_A_ELEC;
  let eB=th/360*PPR + PHASE_B_ELEC;
  const Araw = (((eA%1)+1)%1) < 0.5 ? 1 : 0;
  const Braw = (((eB%1)+1)%1) < 0.5 ? 1 : 0;
  const A = (PPR % 2) ? (1 - Araw) : Araw;
  const B = (PPR % 2) ? (1 - Braw) : Braw;
  return [A,B];
}

// === Quantized counting aligned to real edges (BASE x4) ===
let thetaCumDeg = 0;
let q4_prev = 0;
let phaseOffCycles = 0;
const EPS_EDGE = 1e-9;

// Calibrate offset so x4 borders match the real rising edge of A
function calibratePhaseOffset(){
  const STEP = 0.05; // deg
  let prevA = null, edgeThetaDeg = null;
  for(let th=0; th<360; th+=STEP){
    const [A,_B] = ABfromTheta(th);
    if(prevA===null){ prevA = A; continue; }
    if(prevA===0 && A===1){ edgeThetaDeg = th; break; }
    prevA = A;
  }
  phaseOffCycles = (edgeThetaDeg!==null) ? (-edgeThetaDeg/360) : 0;
  const q4 = Math.floor(PPR * 4 * ((thetaCumDeg/360) + phaseOffCycles) + EPS_EDGE);
  q4_prev = q4;
}

// Count how many integers n in (a, b] satisfy n % 4 in residues; signed by direction
function countResiduesCrossed(a, b, residues){
  if(b === a) return 0;
  const dir = (b > a) ? 1 : -1;
  const lo = dir > 0 ? a : b;
  const hi = dir > 0 ? b : a;
  let c = 0;
  for(const r of residues){
    c += Math.floor((hi - r)/4) - Math.floor((lo - r)/4);
  }
  return dir * c;
}

function onCountingParamsChanged(){ calibratePhaseOffset(); }

// Count with x4 base; derive x2 and x1 by residue logic
function tickAlignedCount(deltaDeg){
  thetaCumDeg += deltaDeg;
  const q4 = Math.floor(PPR * 4 * ((thetaCumDeg/360) + phaseOffCycles) + EPS_EDGE);
  if(q4 !== q4_prev){
    const dq4 = q4 - q4_prev;
    // x4: todos los bordes (A¬± y B¬±)
    countAbsX4 += COUNT_DIR * dq4;
    // x2: flancos de A (¬±) ‚Üí residuos 0 (A‚Üë) y 2 (A‚Üì)
    const c2 = countResiduesCrossed(q4_prev, q4, [0,2]);
    if(c2) countAbsX2 += COUNT_DIR * c2;
    // x1: A‚Üë en el sentido del movimiento (0 al avanzar, 2 al retroceder)
    const residuesX1 = (dq4 >= 0) ? [0] : [2];
    const c1 = countResiduesCrossed(q4_prev, q4, residuesX1);
    if(c1) countAbsX1 += COUNT_DIR * c1;
    q4_prev = q4;    
  }
}

/* ==== Plots (step) ==== */
const plotA=document.getElementById('plotA'), plotB=document.getElementById('plotB');
const ctxA=plotA.getContext('2d'), ctxB=plotB.getContext('2d');
let tSeriesA=[], tSeriesB=[];
function pushSample(t,A,B,win){
  if(t<=lastSampleT+1e-9) return; lastSampleT=t;
  tSeriesA.push([t,A]); tSeriesB.push([t,B]);
  while(tSeriesA.length && tSeriesA[0][0] < t-win) tSeriesA.shift();
  while(tSeriesB.length && tSeriesB[0][0] < t-win) tSeriesB.shift();
  const MAX=1000; if(tSeriesA.length>MAX) tSeriesA.splice(0,tSeriesA.length-MAX);
  if(tSeriesB.length>MAX) tSeriesB.splice(0,tSeriesB.length-MAX);
}
function drawStep(ctx,canvas,series,color,tCenter,win){
  const W=canvas.width, H=canvas.height, P=10;
  const X_PAD = 19;
  const LEFT  = P + X_PAD;
  const WIDTH = W - 2*P - X_PAD;

  ctx.clearRect(0,0,W,H);

  ctx.strokeStyle=getComputedStyle(document.body).getPropertyValue('--axis');
  ctx.strokeRect(LEFT, P, WIDTH, H-2*P);

  ctx.strokeStyle=getComputedStyle(document.body).getPropertyValue('--grid');
  ctx.beginPath();
  const yMid = (H-P-P)*0.5 + P;
  ctx.moveTo(LEFT, yMid); 
  ctx.lineTo(LEFT + WIDTH, yMid);
  ctx.stroke();

  if(series.length===0) return;

  const t0   = tCenter - win*VIEW_FACTOR;
  const mapX = (t) => LEFT + (t - t0) / win * WIDTH;
  const y0   = (v)  => (1 - v) * (H - 2*P) + P;

  let v=series[0][1]; 
  for(let i=0;i<series.length;i++){ if(series[i][0]<=t0) v=series[i][1]; else break; }

  ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath();
  let xPrev = mapX(t0), yPrev = y0(v);
  ctx.moveTo(xPrev, yPrev);

  for(let i=0;i<series.length;i++){
    const [ts,vs]=series[i]; if(ts<t0) continue;
    const x=mapX(ts);
    ctx.lineTo(x, yPrev);
    if(v!==vs){ const y=y0(vs); ctx.lineTo(x,y); yPrev=y; v=vs; }
  }
  ctx.lineTo(LEFT + WIDTH, yPrev); 
  ctx.stroke();

  const xc = LEFT + VIEW_FACTOR * WIDTH;
  ctx.strokeStyle=getComputedStyle(document.body).getPropertyValue('--red'); 
  ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.moveTo(xc,P); ctx.lineTo(xc,H-P); ctx.stroke();

  ctx.fillStyle=getComputedStyle(document.body).getPropertyValue('--fg');
  ctx.font="18px monospace";
  ctx.fillText("1", LEFT-18, P+6);
  ctx.fillText("0", LEFT-18, H-6);
}

function drawPlots(){
  if(mode==='const' && running && Math.abs(rpm)>1e-6){
    const fA = Math.abs(rpm)*PPR/60;
    winWindow = Math.max(0.2, Math.min(5, 4/Math.max(0.1, fA)));
  }

  const [A, B] = ABfromTheta(thetaDeg);

  pushSample(tSim, A, B, winWindow);
  drawStep(ctxA, plotA, tSeriesA, getComputedStyle(document.body).getPropertyValue('--a'), tSim, winWindow);
  drawStep(ctxB, plotB, tSeriesB, getComputedStyle(document.body).getPropertyValue('--b'), tSim, winWindow);
}

/* ==== M√©tricas ==== */
const mAbs=document.getElementById('m_abs');
const mTrue=document.getElementById('m_true');
const mAngAbs=document.getElementById('m_angAbs');
function currentCount(){ 
  return (countModeVal==='x4') ? countAbsX4
       : (countModeVal==='x2') ? countAbsX2
       :                         countAbsX1;
}
function currentCPR(){
  return (countModeVal==='x4') ? (PPR*4)
       : (countModeVal==='x2') ? (PPR*2)
       : PPR;
}

function updateMetrics(){
  const cnt=currentCount(), cpr=currentCPR();
  const angMeasuredAbs=(cnt/cpr)*360;
  mAbs.textContent=cnt.toString();
  mTrue.textContent = `${(TRUE_ANGLE_DIR * thetaDeg).toFixed(2)}¬∞`;
  mAngAbs.textContent=`${angMeasuredAbs.toFixed(2)}¬∞`;
}

/* ==== Loop ==== */
const rotorEl=document.getElementById('rotor');
let lastT=performance.now();
function tick(){
  const t=performance.now(), dt=(t-lastT)/1000; lastT=t;

  if(mode==='const' && running){
    const omega=rpm*2*Math.PI/60;
    thetaDeg += omega*180/Math.PI*dt;
    tSim += dt;
  }else if(mode==='manual'){
    if(Math.abs(thetaDeg-lastThetaDeg)>1e-6 || keyMovePending){ tSim += dt; keyMovePending=false; }
  }
  const deltaDeg = thetaDeg - lastThetaDeg;
  lastThetaDeg=thetaDeg;

  // Conteo robusto por cuantizaci√≥n alineada (sin p√©rdidas)
  tickAlignedCount(deltaDeg);

  const phi=(((thetaDeg + INIT_OFFSET_DEG + oddParityDeg())%360)+360)%360;
  rotorEl.setAttribute('transform',`rotate(${phi} ${CX} ${CY})`);

  updateMetrics();
  drawPlots();

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
</script>
</body>
</html>
"""
from pathlib import Path
out = Path("/mnt/data/index_clean.html")
out.write_text(clean_html, encoding="utf-8")
print("Wrote", out)
